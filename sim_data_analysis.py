"""
Simulation Data Analysis Module for TBG (Twisted Bilayer Graphene) Results.

This module provides tools for analyzing simulation data from TBG Dirac point calculations.
It reads CSV files generated by the training data generation process and provides
structured data access for analysis and visualization.

Key Features:
- Read simulation data from CSV files
- Calculate derived parameters (theta, weight_ratio)
- Remove duplicate theta values and symmetric cases
- Structured data storage for analysis
- GUI for velocity vs theta plotting

Functions:
    load_simulation_data: Convenience function to quickly load simulation data
    quick_summary: Quick summary of simulation data
    run_analysis_gui: Run the analysis GUI application
    test_data_structure: Test function to verify data structure
"""

# Common imports from data_structures_for_training_data
from data_structures_for_training_data import (
    sys, os, csv, ABC, abstractmethod, constants,
    List, Dict, Optional, Union, Tuple, Callable,
    QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QPushButton,
    QLabel, QWidget, QGroupBox, QFormLayout, QLineEdit, QCheckBox,
    QSizePolicy, QSplitter, QTabWidget, QComboBox, QMessageBox,
    QListWidget, QListWidgetItem, Qt, QTimer, QColor,
    FigureCanvas, NavigationToolbar, Figure,
    simulation_data_point, PlotMode, plot_config, filter_config
)
from simulation_data_loader import (
    simulation_data_analyzer, convert_relative_to_absolute_k, 
    get_k_space_unit_cell_limits, is_theta_equivalent
)

logger = constants.logging.getLogger(__name__)


class qwidget_abc_meta(type(QWidget), type(ABC)):
    """Custom metaclass to resolve QWidget and ABC inheritance conflict."""
    pass

class base_plot_widget(QWidget, ABC, metaclass=qwidget_abc_meta):
    """
    Base class for all plot widgets providing common functionality.
    """
    
    def __init__(self, analyzer: simulation_data_analyzer, config: plot_config):
        super().__init__()
        self.analyzer = analyzer
        self.config = config
        self.current_mode = PlotMode.VELOCITY  # Default to velocity mode
        self.color_by_file = False  # Whether to color points by source file
        self.figure = None
        self.canvas = None
        self.toolbar = None
        self.mode_toggle_btn = None
        self.file_color_toggle_btn = None
        self.init_ui()
        self.plot_data()
    
    def init_ui(self) -> None:
        """Initialize the plot widget UI."""
        layout = QVBoxLayout()
        
        # Create mode toggle and export buttons
        toggle_layout = QHBoxLayout()
        self.mode_toggle_btn = QPushButton("Switch to K-Point View")
        self.mode_toggle_btn.clicked.connect(self.toggle_plot_mode)
        toggle_layout.addWidget(self.mode_toggle_btn)
        
        # Add file coloring toggle button (initially hidden, shown when multiple files loaded)
        self.file_color_toggle_btn = QPushButton("Color by File")
        self.file_color_toggle_btn.setCheckable(True)
        self.file_color_toggle_btn.clicked.connect(self.toggle_file_coloring)
        self.file_color_toggle_btn.setVisible(len(self.analyzer.loaded_files) > 1)
        toggle_layout.addWidget(self.file_color_toggle_btn)
        
        # Add export button
        self.export_btn = QPushButton("Export Plot")
        self.export_btn.clicked.connect(self.export_plot)
        toggle_layout.addWidget(self.export_btn)
        
        toggle_layout.addStretch()  # Push buttons to the left
        
        layout.addLayout(toggle_layout)
        
        # Create matplotlib figure and canvas with better size management
        self.figure = Figure(figsize=(10, 7), facecolor='white')
        self.canvas = FigureCanvas(self.figure)
        self.canvas.setMinimumSize(600, 400)
        self.toolbar = NavigationToolbar(self.canvas, self)
        
        layout.addWidget(self.toolbar)
        layout.addWidget(self.canvas)
        
        self.setLayout(layout)
    
    def toggle_plot_mode(self) -> None:
        """Toggle between velocity and k-point plot modes."""
        if self.current_mode == PlotMode.VELOCITY:
            self.current_mode = PlotMode.KPOINT
            self.mode_toggle_btn.setText("Switch to Velocity View")
        else:
            self.current_mode = PlotMode.VELOCITY
            self.mode_toggle_btn.setText("Switch to K-Point View")
        
        # Refresh the plot with the new mode
        self.plot_data()
    
    def toggle_file_coloring(self) -> None:
        """Toggle file-based coloring on/off."""
        self.color_by_file = not self.color_by_file
        if self.file_color_toggle_btn:
            self.file_color_toggle_btn.setChecked(self.color_by_file)
        
        # Refresh the plot with the new coloring
        self.plot_data()
    
    def update_file_button_visibility(self) -> None:
        """Update the visibility of the file coloring button based on loaded files."""
        if self.file_color_toggle_btn:
            should_show = len(self.analyzer.loaded_files) > 1
            self.file_color_toggle_btn.setVisible(should_show)
            if not should_show:
                self.color_by_file = False
                self.file_color_toggle_btn.setChecked(False)
    
    def export_plot(self) -> None:
        """Export the current plot to a file with format selection dialog."""
        from PyQt6.QtWidgets import QFileDialog
        import os
        
        try:
            # Determine default filename based on current mode and config
            mode_suffix = "kpoint" if self.current_mode == PlotMode.KPOINT else "velocity"
            x_param = self.config.x_param.replace("_", "-")
            default_name = f"{x_param}-vs-{mode_suffix}"
            
            # Create file dialog with format options
            file_dialog = QFileDialog()
            file_dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptSave)
            file_dialog.setNameFilters([
                "PNG Image (*.png)",
                "PDF Document (*.pdf)", 
                "SVG Vector (*.svg)",
                "EPS Vector (*.eps)",
                "TIFF Image (*.tiff)",
                "JPEG Image (*.jpg)"
            ])
            file_dialog.setDefaultSuffix("png")
            file_dialog.selectFile(default_name)
            
            if file_dialog.exec() == QFileDialog.DialogCode.Accepted:
                file_path = file_dialog.selectedFiles()[0]
                
                # Get export settings based on format
                file_ext = os.path.splitext(file_path)[1].lower()
                export_settings = self.get_export_settings(file_ext)
                
                # Export the plot
                self.figure.savefig(file_path, **export_settings)
                
                logger.info(f"Plot exported successfully to: {file_path}")
                
                # Show success message briefly on the export button
                original_text = self.export_btn.text()
                self.export_btn.setText("âœ“ Exported!")
                QTimer.singleShot(2000, lambda: self.export_btn.setText(original_text))
        
        except Exception as e:
            logger.error(f"Error exporting plot: {e}")
            # Show error message briefly on the export button
            original_text = self.export_btn.text()
            self.export_btn.setText("Export Failed")
            QTimer.singleShot(2000, lambda: self.export_btn.setText(original_text))
    
    def get_export_settings(self, file_ext: str) -> dict:
        """Get export settings based on file format."""
        base_settings = {
            'bbox_inches': 'tight',
            'pad_inches': 0.2,
            'facecolor': 'white',
            'edgecolor': 'none'
        }
        
        format_specific = {
            '.png': {'dpi': 300, 'format': 'png'},
            '.pdf': {'dpi': 300, 'format': 'pdf'},
            '.svg': {'format': 'svg'},
            '.eps': {'dpi': 300, 'format': 'eps'},
            '.tiff': {'dpi': 300, 'format': 'tiff'},
            '.jpg': {'dpi': 300, 'format': 'jpeg', 'quality': 95},
            '.jpeg': {'dpi': 300, 'format': 'jpeg', 'quality': 95}
        }
        
        settings = base_settings.copy()
        settings.update(format_specific.get(file_ext, format_specific['.png']))
        return settings
    
    def get_plot_data(self, filtered_data: List[simulation_data_point] = None) -> Tuple[List[float], List[float]]:
        """Extract x and y data from data points."""
        data_to_plot = filtered_data if filtered_data is not None else self.analyzer.data_points
        
        x_data = [getattr(dp, self.config.x_param) for dp in data_to_plot]
        y_data = [getattr(dp, self.config.y_param) for dp in data_to_plot]
        
        return x_data, y_data
    
    def plot_data(self, filtered_data: List[simulation_data_point] = None) -> None:
        """Plot data using the configuration and current mode."""
        try:
            data_to_plot = filtered_data if filtered_data is not None else self.analyzer.data_points
            
            if not data_to_plot:
                self.plot_no_data()
                return
            
            # Clear previous plot
            self.figure.clear()
            # Use fixed subplot parameters to maintain consistent plot size
            ax = self.figure.add_subplot(111, position=[0.1, 0.1, 0.75, 0.8])
            
            if self.current_mode == PlotMode.VELOCITY:
                # Standard velocity plot
                x_data, y_data = self.get_plot_data(filtered_data)
                
                if self.color_by_file and len(self.analyzer.loaded_files) > 1:
                    # Color points by source file
                    import matplotlib.pyplot as plt
                    
                    # Group data by file
                    file_groups = {}
                    for dp in data_to_plot:
                        file_name = dp.source_file or 'unknown'
                        if file_name not in file_groups:
                            file_groups[file_name] = {'x': [], 'y': []}
                        file_groups[file_name]['x'].append(getattr(dp, self.config.x_param))
                        file_groups[file_name]['y'].append(getattr(dp, self.config.y_param))
                    
                    # Plot each file group with different color
                    for file_name, data_group in file_groups.items():
                        color = self.analyzer.file_colors.get(file_name, 'gray')
                        ax.scatter(data_group['x'], data_group['y'], 
                                 alpha=0.6, s=20, color=color, label=file_name)
                    
                    ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
                else:
                    # Standard single-color plot
                    ax.scatter(x_data, y_data, alpha=0.6, s=20)
                
                ax.set_xlabel(self.config.x_label)
                ax.set_ylabel(self.config.y_label)
                ax.set_title(self.config.title)
                
                # Apply custom formatting if available
                if self.config.x_formatter:
                    ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: self.config.x_formatter(x)))
                
                logger.info(f"Plotted {len(x_data)} data points ({self.config.x_param} vs {self.config.y_param})")
                
            elif self.current_mode == PlotMode.KPOINT:
                # K-point scatter plot
                k_x_data = [dp.k_x_abs for dp in data_to_plot]
                k_y_data = [dp.k_y_abs for dp in data_to_plot]
                
                if self.color_by_file and len(self.analyzer.loaded_files) > 1:
                    # Color points by source file
                    import matplotlib.pyplot as plt
                    
                    # Group data by file
                    file_groups = {}
                    for dp in data_to_plot:
                        file_name = dp.source_file or 'unknown'
                        if file_name not in file_groups:
                            file_groups[file_name] = {'k_x': [], 'k_y': []}
                        file_groups[file_name]['k_x'].append(dp.k_x_abs)
                        file_groups[file_name]['k_y'].append(dp.k_y_abs)
                    
                    # Plot each file group with different color
                    for file_name, data_group in file_groups.items():
                        color = self.analyzer.file_colors.get(file_name, 'gray')
                        ax.scatter(data_group['k_x'], data_group['k_y'], 
                                 alpha=0.7, s=30, color=color, label=file_name)
                    
                    ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
                    color_label = "Source File"
                    
                else:
                    # Color by parameter (original behavior)
                    # Determine color parameter based on original config
                    if self.config.x_param == "theta":
                        # Color by theta for velocity vs theta tab
                        color_data = [dp.theta for dp in data_to_plot]
                        color_label = "Theta (degrees)"
                    elif self.config.x_param == "weight_ratio":
                        # Color by weight_ratio for velocity vs weight_ratio tab
                        color_data = [dp.weight_ratio for dp in data_to_plot] 
                        color_label = "Weight Ratio"
                    elif self.config.x_param == "interlayer_dist_threshold":
                        # Color by interlayer threshold for velocity vs interlayer tab
                        color_data = [dp.interlayer_dist_threshold for dp in data_to_plot]
                        color_label = "Interlayer Threshold"
                    elif self.config.x_param == "intralayer_dist_threshold":
                        # Color by intralayer threshold for velocity vs intralayer tab
                        color_data = [dp.intralayer_dist_threshold for dp in data_to_plot]
                        color_label = "Intralayer Threshold"
                    else:
                        # Default to theta
                        color_data = [dp.theta for dp in data_to_plot]
                        color_label = "Theta (degrees)"
                    
                    # Create scatter plot with color mapping
                    scatter = ax.scatter(k_x_data, k_y_data, c=color_data, alpha=0.7, s=30, cmap='viridis')
                    
                    # Add colorbar in fixed position
                    cbar_ax = self.figure.add_axes([0.87, 0.1, 0.03, 0.8])  # [left, bottom, width, height]
                    cbar = self.figure.colorbar(scatter, cax=cbar_ax)
                    cbar.set_label(color_label)
                
                ax.set_xlabel('$k_x$ (absolute coordinates)')
                ax.set_ylabel('$k_y$ (absolute coordinates)')
                ax.set_title(f'K-Points in Reciprocal Space (colored by {color_label})')
                
                # Make axes equal to preserve aspect ratio
                ax.set_aspect('equal')
                
                # Set fixed limits based on N=1 unit cell
                (k_x_min, k_x_max), (k_y_min, k_y_max) = get_k_space_unit_cell_limits()
                ax.set_xlim(k_x_min, k_x_max)
                ax.set_ylim(k_y_min, k_y_max)
                
                # Add unit cell boundary visualization for centered unit cell
                k1 = constants.k1
                k2 = constants.k2
                
                # Draw the centered unit cell parallelogram (relative coords: -0.5 to 0.5)
                # Convert the corners from relative to absolute coordinates
                rel_corners = [(-0.5, -0.5), (0.5, -0.5), (0.5, 0.5), (-0.5, 0.5), (-0.5, -0.5)]  # Close the loop
                unit_cell_x = []
                unit_cell_y = []
                
                for rel_x, rel_y in rel_corners:
                    abs_x = rel_x * k1[0] + rel_y * k2[0]
                    abs_y = rel_x * k1[1] + rel_y * k2[1]
                    unit_cell_x.append(abs_x)
                    unit_cell_y.append(abs_y)
                
                ax.plot(unit_cell_x, unit_cell_y, 'r--', alpha=0.5, linewidth=1, label='Unit cell boundary')
                ax.legend(loc='upper right', fontsize=8)
                
                logger.info(f"Plotted {len(k_x_data)} k-points colored by {color_label} with limits: kx=[{k_x_min:.3f}, {k_x_max:.3f}], ky=[{k_y_min:.3f}, {k_y_max:.3f}]")
            
            ax.grid(True, alpha=0.3)
            
            # Fixed layout - no dynamic adjustments to maintain consistent plot size
            self.canvas.draw()
            
        except Exception as e:
            logger.error(f"Error plotting in {self.current_mode} mode: {e}")
    
    def plot_no_data(self) -> None:
        """Show 'no data' message."""
        self.figure.clear()
        # Use same fixed positioning as main plots
        ax = self.figure.add_subplot(111, position=[0.1, 0.1, 0.75, 0.8])
        ax.text(0.5, 0.5, 'No data points match the current filter', 
               horizontalalignment='center', verticalalignment='center', 
               transform=ax.transAxes, fontsize=12)
        ax.set_xlabel(self.config.x_label)
        ax.set_ylabel(self.config.y_label)
        ax.set_title(self.config.title)
        self.canvas.draw()
    
    def cleanup(self) -> None:
        """Clean up resources."""
        if self.figure:
            self.figure.clear()
        if self.canvas:
            self.canvas.deleteLater()
        if self.toolbar:
            self.toolbar.deleteLater()
        if hasattr(self, 'mode_toggle_btn') and self.mode_toggle_btn:
            self.mode_toggle_btn.deleteLater()
        if hasattr(self, 'export_btn') and self.export_btn:
            self.export_btn.deleteLater()

class base_parameter_control_widget(QWidget):
    """
    Base class for parameter control widgets providing common functionality.
    """
    
    def __init__(self, analyzer: simulation_data_analyzer, plot_widget: base_plot_widget, 
                 filter_configs: List[filter_config]):
        super().__init__()
        self.analyzer = analyzer
        self.plot_widget = plot_widget
        self.filter_configs = filter_configs
        self.filter_dropdowns = {}
        self.init_ui()
    
    def init_ui(self) -> None:
        """Initialize the parameter control UI."""
        layout = QVBoxLayout()
        
        # Data summary group
        summary_group = QGroupBox("Data Summary")
        summary_layout = QFormLayout()
        
        if self.analyzer.data_points:
            summary = self.analyzer.get_data_summary()
            summary_layout.addRow("Total Points:", QLabel(str(summary.get("total_points", 0))))
            
            # Add relevant ranges based on plot config
            x_param = self.plot_widget.config.x_param
            y_param = self.plot_widget.config.y_param
            
            if f"{x_param}_range" in summary:
                x_range = summary[f"{x_param}_range"]
                x_label = self.plot_widget.config.x_label
                summary_layout.addRow(f"{x_label} Range:", 
                                    QLabel(f"{x_range[0]:.3f} - {x_range[1]:.3f}"))
            
            if f"{y_param}_range" in summary:
                y_range = summary[f"{y_param}_range"]
                y_label = self.plot_widget.config.y_label
                summary_layout.addRow(f"{y_label} Range:", 
                                    QLabel(f"{y_range[0]:.3f} - {y_range[1]:.3f}"))
        else:
            summary_layout.addRow("Status:", QLabel("No data loaded"))
        
        summary_group.setLayout(summary_layout)
        layout.addWidget(summary_group)
        
        # Parameter filters group
        if self.analyzer.data_points:
            filter_group = QGroupBox("Parameter Filters")
            filter_layout = QFormLayout()
            
            for filter_cfg in self.filter_configs:
                # Get unique values for this parameter with matching precision
                unique_values = self.analyzer.get_unique_parameter_values(filter_cfg.param_name, filter_cfg.precision)
                
                if unique_values:
                    dropdown = QComboBox()
                    dropdown.addItem("All Values")  # Default option to show all
                    
                    # Add unique values as options
                    for value in unique_values:
                        if isinstance(value, float):
                            if filter_cfg.formatter:
                                dropdown.addItem(filter_cfg.formatter(value))
                            else:
                                dropdown.addItem(f"{value:.{filter_cfg.precision}f}")
                        else:
                            dropdown.addItem(str(value))
                    
                    self.filter_dropdowns[filter_cfg.param_name] = dropdown
                    filter_layout.addRow(filter_cfg.display_name + ":", dropdown)
            
            filter_group.setLayout(filter_layout)
            layout.addWidget(filter_group)
        
        # Update button
        update_btn = QPushButton("Update Plot")
        update_btn.clicked.connect(self.update_plot)
        layout.addWidget(update_btn)
        
        layout.addStretch()
        self.setLayout(layout)
    
    def get_current_filters(self) -> Dict[str, Union[float, str]]:
        """Get current filter values from dropdown selections."""
        filters = {}
        
        for filter_cfg in self.filter_configs:
            param = filter_cfg.param_name
            if param in self.filter_dropdowns:
                dropdown = self.filter_dropdowns[param]
                selected_text = dropdown.currentText()
                if selected_text != "All Values":
                    try:
                        # Parse value based on formatter
                        if filter_cfg.formatter:
                            # Remove formatting symbols and convert
                            clean_text = selected_text.replace('Â°', '').strip()
                            parsed_value = float(clean_text)
                            # Round to the same precision used for unique values
                            filters[param] = round(parsed_value, filter_cfg.precision)
                        else:
                            parsed_value = float(selected_text)
                            # Round to the same precision used for unique values
                            filters[param] = round(parsed_value, filter_cfg.precision)
                    except ValueError:
                        filters[param] = selected_text
        
        return filters
    
    def update_plot(self) -> None:
        """Update the plot with current filter selections."""
        try:
            filters = self.get_current_filters()
            
            if not filters:
                filtered_data = self.analyzer.data_points
            else:
                filtered_data = self.apply_filters(filters)
            
            # Update the plot
            self.plot_widget.plot_data(filtered_data)
            
            # Update button with status
            self.update_button_status(len(filtered_data), len(self.analyzer.data_points))
            
            logger.info(f"Plot updated: showing {len(filtered_data)}/{len(self.analyzer.data_points)} points with filters: {filters}")
            
            # Debug: Log some actual data values when filtering returns no results
            if len(filtered_data) == 0 and filters:
                for param, target_val in filters.items():
                    actual_values = [round(getattr(dp, param), 
                                         next((cfg.precision for cfg in self.filter_configs if cfg.param_name == param), 3)) 
                                   for dp in self.analyzer.data_points[:5]]  # Just first 5 for debugging
                    logger.debug(f"No matches for {param}={target_val}, actual values sample: {actual_values}")
            
        except Exception as e:
            logger.error(f"Error updating plot with filters: {e}")
    
    def apply_filters(self, filters: Dict[str, Union[float, str]]) -> List[simulation_data_point]:
        """Apply filters to data points."""
        filtered_data = []
        
        for dp in self.analyzer.data_points:
            include = True
            for param, target_value in filters.items():
                if hasattr(dp, param):
                    actual_value = getattr(dp, param)
                    
                    # Find the filter config for this parameter
                    filter_cfg = next((cfg for cfg in self.filter_configs if cfg.param_name == param), None)
                    
                    if isinstance(target_value, float):
                        # Use precision from filter config for comparison
                        precision = filter_cfg.precision if filter_cfg else 3
                        actual_rounded = round(actual_value, precision)
                        target_rounded = round(target_value, precision)
                        if actual_rounded != target_rounded:
                            include = False
                            break
                    else:
                        if str(actual_value) != str(target_value):
                            include = False
                            break
            
            if include:
                filtered_data.append(dp)
        
        return filtered_data
    
    def update_button_status(self, filtered_count: int, total_count: int) -> None:
        """Update button text with status temporarily."""
        update_btn = self.sender()
        if update_btn:
            original_text = update_btn.text()
            status_text = f"Showing {filtered_count}/{total_count} data points"
            update_btn.setText(status_text)
            QTimer.singleShot(3000, lambda: update_btn.setText(original_text))
    
    def cleanup(self) -> None:
        """Clean up resources."""
        for dropdown in self.filter_dropdowns.values():
            dropdown.deleteLater()
        self.filter_dropdowns.clear()

# Convenience functions for quick analysis
def load_simulation_data(data_folder: str = None, filename: str = "dirac_training_data.csv") -> simulation_data_analyzer:
    """
    Convenience function to quickly load simulation data.
    
    Args:
        data_folder: Path to data folder
        filename: CSV filename to load
        
    Returns:
        Initialized and loaded simulation_data_analyzer instance
    """
    analyzer = simulation_data_analyzer(data_folder)
    analyzer.load_csv_data(filename)
    return analyzer

def quick_summary(data_folder: str = None, filename: str = "dirac_training_data.csv") -> Dict:
    """
    Quick summary of simulation data.
    
    Args:
        data_folder: Path to data folder  
        filename: CSV filename to analyze
        
    Returns:
        Dictionary with summary statistics
    """
    analyzer = load_simulation_data(data_folder, filename)
    return analyzer.get_data_summary()

def run_analysis_gui(data_folder: str = None) -> None:
    """
    Run the analysis GUI application.
    
    Args:
        data_folder: Path to data folder (optional)
    """
    from gui_data_analysis import run_analysis_gui as gui_run_analysis_gui
    gui_run_analysis_gui(data_folder)

def test_data_structure() -> None:
    """Test function to verify data structure is working correctly."""
    try:
        # Test creating a sample data point
        test_point = simulation_data_point(
            a=5, b=1, theta=30.0, 
            interlayer_dist_threshold=1.0, intralayer_dist_threshold=1.5,
            inter_graph_weight=0.5, intra_graph_weight=1.0, weight_ratio=2.0,
            k_x=0.1, k_y=0.2, k_x_abs=0.15, k_y_abs=0.25, velocity=1000.0
        )
        
        # Test that all expected parameters exist
        expected_params = ['a', 'b', 'theta', 'interlayer_dist_threshold', 'intralayer_dist_threshold',
                          'inter_graph_weight', 'intra_graph_weight', 'weight_ratio', 'k_x', 'k_y', 
                          'k_x_abs', 'k_y_abs', 'velocity', 'source_file', 'file_index']
        
        for param in expected_params:
            if not hasattr(test_point, param):
                logger.error(f"Missing parameter: {param}")
                return False
                
        logger.info("Data structure test passed")
        return True
        
    except Exception as e:
        logger.error(f"Data structure test failed: {e}")
        return False

if __name__ == "__main__":
    # Test data structure first
    if not test_data_structure():
        print("Data structure test failed - check logs")
        sys.exit(1)
    
    # Example usage
    try:
        # Run GUI application
        run_analysis_gui()
        
    except Exception as e:
        print(f"Error running analysis: {e}")
        logger.error(f"Error in main: {e}")